<h1> Closures y Scope en JavaScript</h1>

<h3>Oscar Barajas Tavares</h3>

<h1>Tabal de Contenido</h1>

- [1. Bienvenida](#1-bienvenida)
  - [Introducci√≥n y bienvenida al curso](#introducci√≥n-y-bienvenida-al-curso)
- [2. Scope](#2-scope)
  - [Qu√© es el Scope y c√≥mo funciona el Global Scope](#qu√©-es-el-scope-y-c√≥mo-funciona-el-global-scope)
  - [Local Scope](#local-scope)
  - [Function Scope](#function-scope)
  - [Block Scope](#block-scope)
- [3. Closure](#3-closure)
  - [¬øQu√© es un closure?](#qu√©-es-un-closure)
  - [√Åmbito l√©xico en closures](#√°mbito-l√©xico-en-closures)
  - [C√≥mo crear variables privadas con closures](#c√≥mo-crear-variables-privadas-con-closures)
  - [Loops](#loops)
- [4. Hoisting](#4-hoisting)
  - [¬øQu√© es el hoisting?](#qu√©-es-el-hoisting)
- [5. Debugging](#5-debugging)
  - [Debugging](#debugging)
- [6. Cierre](#6-cierre)
  - [Conclusiones](#conclusiones)


# 1. Bienvenida

## Introducci√≥n y bienvenida al curso

- [GitHub - platzi/curso-scope-closure](https://github.com/platzi/curso-scope-closure/tree/master)

# 2. Scope

## Qu√© es el Scope y c√≥mo funciona el Global Scope

- `Scope:` Es el alcance que va a tener una variable dentro del c√≥digo. En otras palabras, el Scope se encargar√° de decidir a que bloques de c√≥digo va a acceder una variable.

- `Global Scope :` No est√°n dentro de funciones o bloques, por lo tanto se puede acceder a ellas de manera global.

Con var podemos re-asignar una variable pero es una mala pr√°ctica.

Con let y const no podemos, aparecer√° un error.

Es una mala pr√°ctica crear una variable sin las palabras reservadas: `var`, `let` y `const`.
Si se asigna una variable dentro de una funci√≥n sin las palabras reservadas ser√° una variable global.

La doble asignaci√≥n de una variable tambi√©n es una mala pr√°ctica.

Al declarar la variable con var podemos declarar nuevamente la variable.

```js
// Esto no causa error
var hVar = 'hVar'
var hVar = 'hVar...'
```

No as√≠ cuando se utiliza `let` o `const`.

```js
// Esto genera un SyntaxError debido a que la variable hlet se intenta declarar por segunda vez.
let hlet = 'hlet'
let hlet = 'hlet...'
```

Pero si podemos asignar un nuevo valor

```js
let hlet = 'hlet'
hlet = 'hlet_update'
```

Con `const` no podemos declarar la variable nuevamente y tampoco podemos asignar valor por segunda vez

```js
// error
const hconst = 'hlet'
const hconst = 'hlet'
// error
const hconst = 'hlet' 
hconst = 'hlet'
```

- [Download Visual Studio Code - Mac, Linux, Windows](https://code.visualstudio.com/download)
- [Code Runner - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner)

## Local Scope

Lexical Scope / √Åmbito L√©xico: El int√©rprete de JavaScript funciona desde el √°mbito de ejecuci√≥n actual y funciona hasta encontrar la variable en cuesti√≥n. Si la variable no se encuentra en ning√∫n √°mbito, se genera una excepci√≥n.

Este tipo de b√∫squeda se llama √°mbito l√©xico. El alcance de una variable se define por su ubicaci√≥n dentro del c√≥digo fuente, y las funciones anidadas tienen acceso a las variables declaradas en su alcance externo. No importa de d√≥nde se llame una funci√≥n, o incluso c√≥mo se llama, su alcance l√©xico depende solo de d√≥nde se declar√≥ la funci√≥n.

El scope se puede definir como el alcance que puede tener una variable en tu codigo.

El Local Scope: se refiere a la variable o funcion que esta dentro de un bloque o funcion especifica. Solo se pueden acceder a ellas (ejecutar o llamar) dentro del entrono en donde conviven.

El ambito lexico: se refiere a que una funcion puede acceder a una funcion o variable fuera de ella.Cada nivel interno puede acceder a sus niveles externos hasta poder alcanzarlas.

El `scope local` nos permite acceder una variable en un bloque de c√≥digo o estructura, como las funciones. Por lo tanto el scope global no puede acceder a las variables dentro de un bloque de c√≥digo.

Si se anida una `funci√≥n` dentro de otra, las variables de la primera funci√≥n van a poder ser accedidas dentro de la segunda.

## Function Scope

Las variables escritas con la palabra clave var pueden ser redeclaradas, pero esto a futuro puede darnos problemas, as√≠ que es mejor no usarla.

Las variables escritas con la palabra clave `let` no pueden ser redeclaradas, si lo haces mostrara un ‚Äúerror: esta variable ya ha sido declarada‚Äù , pero su valor puede ser reasignado:

```js
let fruit = "apple";
fruit = "banana";

console.log(fruit); // banana
```

Las variables escritas con la palabra clave const no pueden ser redeclaradas o reasignadas, ya que const quiere decir que su valor ser√° constante, es decir que no va a cambiar.

## Block Scope

Las variables escritas con la palabra clave var pueden ser redeclaradas, pero esto a futuro puede darnos problemas, as√≠ que es mejor no usarla.

Las variables escritas con la palabra clave let no pueden ser redeclaradas, si lo haces mostrara un ‚Äúerror: esta variable ya ha sido declarada‚Äù , pero su valor puede ser reasignado:

```js
let fruit = "apple";
fruit = "banana";

console.log(fruit); // banana
```

Las variables escritas con la palabra clave const no pueden ser redeclaradas o reasignadas, ya que const quiere decir que su valor ser√° constante, es decir que no va a cambiar.

Creo que hay un error de significado. SI se puede reasignar let, lo que no se puede es redeclarar.

Reasignar:

```js
let a = 1;
a = 2 // correcto
```

Redeclarar:

```js
let a = 1;
let a = 2; //incorrecto
```

var se puede tanto reasignar como redeclarar, y const no se puede ninguna de las dos

- [VAR vs LET vs CONST: TODAS LAS DIFERENCIAS](https://www.youtube.com/watch?v=ojrvxYcKeYg)

# 3. Closure
## ¬øQu√© es un closure?

Una clausura o closure es una funci√≥n que guarda referencias del estado adyacente (√°mbito l√©xico). En otras palabras, una clausura permite acceder al √°mbito de una funci√≥n exterior desde una funci√≥n interior. En JavaScript, las clausuras se crean cada vez que una funci√≥n es creada.

Cuando declaramos una funci√≥n dentro de nuestro global scope, estamos usando un closure.

```js
var myVar = 'hi';
function myFunction() {
	console.log(myVar);
}
myFuntion(); // hi
```

Los closures son basicamente cuando aprovechamos la habilidad de Javascript de usar las variables que est√°n en el scope padre de nuestro bloque de c√≥digo, por eso el global scope es un closure grandote; el bloque myFunction puede usar TODAS las variables que est√°n disponibles en el bloque inmediato anterior.

Usando el ejemplo del profesor:
Si tu declaras la variable saveCoins en el global scope, estar√≠as usando el mismo principio que si usas la segunda funci√≥n que escribe el profesor porque est√°s usando las variables que est√°n en el scope padre.

```js
var saveCoins = 0;

const moneyBox = (coins) => {
    saveCoins += coins;
    console.log(saveCoins);
}

moneyBox(5); //5
moneyBox(10); //15
```

Pero est√° mal visto modificar variables globales, por eso es que quieres crear variables dentro de un scope cerrado y que interactuen entre ellas, entonces declaras las variables que vas a usar dentro del scope padre del bloque que las va a modificar para que siempre pueda acceder a ellas. Para eso creas un nuevo ‚Äúglobal scope‚Äù ficticio que va a conservar todas las variables que t√∫ quieras monitorear:

Ahora mira las similitudes entre el codigo de arriba y el que est√° justo abajo de aqu√≠‚Ä¶

```js
const moneyBox = () => {
    var saveCoins = 0;
    const countCoins = (coins) => {
        saveCoins += coins;
        console.log(saveCoins);
    }
    return countCoins;
}

let myMoneyBox = moneyBox()
myMoneyBox(4)
myMoneyBox(10)
myMoneyBox(6)
```

Si remueves " `const moneyBox = () => {} `" ser√≠an exactamente las mismas lineas de c√≥digo!

```js
//const moneyBox = () => {
    var saveCoins = 0;
    const countCoins = (coins) => {
        saveCoins += coins;
        console.log(saveCoins);
    }
   // return countCoins; 
//}
```

Lo que est√°s haciendo es simplemente bajar un nivel tu scope. Quieres que la funcion moneyBox regrese una funcion que estuvo declarada dentro de s√≠ misma porque esa funci√≥n tiene acceso a ese Scope que ya no va a existir para que alguien m√°s lo use, solamente lo podr√° usar la funci√≥n countCoins. Al guardar el resultado de moneyBox (countCoins) en otra variable est√°s creando el √°mbito l√©xico que menciona el profesor, necesario para no dejar morir ese scope.

## √Åmbito l√©xico en closures

¬øPor qu√© si le mandamos como par√°metro inicial 1, al momento de llamar el closure por primera vez me imprime 1 si lo estoy incrementando?
Bueno, pues yo te lo explico.

Si vemos la estructura de la funci√≥n

```js
const buildCount = (i)=>{
    let count = i;
    const displayCount = () =>{
        console.log(count++);
    }
    return displayCount;
};
```

Podemos notar que el `console.log()` est√° de de la siguiente manera

```js
console.log(count++);
```

Y como ves, aparece `count++,` lo que quiere decir que estamos incrementando en 1 el valor de count, pero de la manera que est√° escrita, primero va a imprimir el count con el valor antes de incrementarlo
Esto se debe a que count++ es lo equivalente a decir` count = count + 1` pero el momento en el que se har√° ese incremento, est√° dado por la posici√≥n del `++`, en √©ste caso, se har√° despu√©s.
Si quisieramos que se muestre el valor de count despu√©s de hacerle el incremento, podr√≠amos hacer √©sto:

```js
count++;
console.log(count);
```

O, de una manera m√°s elegante, y aprendiendo como funciona el `++`, as√≠:

```js
console.log(++count);
```

Espero haberte ayudado y suerte en el camino a la maestr√≠a üòâ

El √°mbito l√©xico es cuando las funciones se ejecutan utilizando la cadena del alcance donde estaban vigente en su momento.

Esto significa que podemos acceder al valor ‚Äúcount‚Äù dentro de la funci√≥n porque es el alcance donde est√° asignado.

Podemos tener varias formas de manejar la constante ‚ÄúbuildCount‚Äù, significa que la podemos asignar a myCount y myOtherCount. Trabajaremos con el scope(alcance) que tiene esta variable, poder ejecutarla y empezar a contar desde donde necesitemos.

```js
const buildCount = i => {
  let count = i;
  const displayCount = () => {
    console.log(count++);
  };
  return displayCount;
};

const myCount = buildCount(1);
myCount(); // 1
myCount(); // 2
myCount(); // 3

const myOtherCount = buildCount(10);
myOtherCount(); // 10
myOtherCount(); // 11
```

## C√≥mo crear variables privadas con closures

Variables privadas con Closures: JS por su naturaleza no fomenta el uso de datos privados pero por medio de los Closures podemos crear valores que solo puedan ser accedidos por medio de m√©todos, que no van a estar disponibles fuera de esta funci√≥n.

```js
const person = () => {
  let saveName = "Name";
  return {
    getName: () => saveName,
    setName: (name) => {
      saveName = name;
    },
  };
};

const newPerson = person();
console.log(newPerson.getName());
newPerson.setName('Edward');
console.log(newPerson.getName());
```

## Loops

Podemos crear Closures de diferentes formas y tambi√©n de forma involuntaria, esto significa que no tenemos control de lo que estamos creando, tenemos que tener cuidado con nuestras asignaciones o bloques de c√≥digo que de alguna manera nosotros no controlemos muchas veces sucede porque no establecimos nuestros elementos correctamente.

Con el uso del Scope y los Closures podemos optimizar nuestros proyectos sin ning√∫n problema.

>  En un loop nunca ocupes var, siempre utiliza let para valores que ir√°n cambiando dentro de la ejecuci√≥n del scope.

# 4. Hoisting

## ¬øQu√© es el hoisting?

El ‚Äòlevantamiento‚Äô del que hablan es mas a fines did√°cticos y est√° bien, pero no es tan as√≠, no es que FISICAMENTE levanta las declaraciones y las pone al principio como muchos explican. Lo que se hace en realidad es tomar ‚Äòregistros‚Äô en memoria de donde est√° cada declaraci√≥n(todo esto previo a que se ejecute el c√≥digo en s√≠) y depende si es var, let, const o una funci√≥n, JS va a asignarle referencias a cada una.
Si es:

- `var :` asigna la referencia undefined (si de ac√° viene el famoso undefined)

- `let/const:` asigna la referencia uninitialized(declarado pero no inicializado)

- `funci√≥n:` guarda un registro con la funci√≥n entera(por eso la podemos llamar antes de que este creada)

> `Hoisting:` Eleva las declaraciones, esto pasa en el momento en que se compila nuestro c√≥digo antes de ser interpretado por el navegador. De esta forma podemos asignar nuestros valores o acceder a un valor que previamente no ha sido declarado dentro de esta estructura.

# 5. Debugging

## Debugging

```js
var a = 'Hello';

function hello () {
    let b = 'Hello world';
    const c = 'Hello world!!';
    if (true) {
        let d = '¬°¬°Hello world!!';
        debugger;
    }
}

hello();
```

> Nada le gana al poderos√≠simo console.log para debugging jajaja, no en serio, siempre que puedan usen debugger, les ser√° de mucha ayuda ^^

Podemos ver de una forma distinta gracias a Chrome con las Chrome Dev Tools. Si en nuestro programa queremos pausar nuestro codigo en una parte, podemos usar la palabra reservada ‚Äúdebugger‚Äù.

Al ejecutar un programa con este programa, Chrome entra al debugger gracias a nuestra declaracion y podemos ver todo lo que esta pasando, el Scope de nuestras variables, la globales . Tambien podemos ver la Call Stack, nuestras asignaciones, agregar breakpoints para saber que esta pasando en cualquier linea de codigo.

# 6. Cierre

## Conclusiones

> Nunca pares de Aprender!